---
/**
 * @since 0.1.0-alpha
 *
 * @packageDocumentation
 */

/* import - types */
import type {
    ColourLevels,
    ColourLevels_Extended,
} from '../../ts/02-tokens/@types.d.ts';
import type { Tokens } from '../../ts/02-tokens/Tokens.js';
import type { Tokens_Colour_ShadeMap } from '../../ts/02-tokens/Colour/Colour_ShadeMap.js';
import type { LevelTargets } from './ShadeSwatchTable.astro';

/* import - functions */
import { toTitleCase } from '@maddimathon/utility-typescript/functions';
import { getLevelsInUse } from '../../ts/02-tokens/getLevelsInUse.js';
import { objectMapAsync } from '../../ts/01-utilities/objectMapAsync.js';
import { ColourUtilities } from '../../ts/01-utilities/ColourUtilities.js';

/* import - values */

/* import - components */
import Toggle from '@maddimathon/utility-astro/components/Toggle';
import ShadeSwatchList from './ShadeSwatchList.astro';
import ShadeSwatchTable from './ShadeSwatchTable.astro';

/* import - layouts */

/* PROPS ===================================== */

export interface Props {
    tokens: Tokens.JsonReturn;

    /**
     * Whether to include the given colour formats in the the shade swatch table.
     *
     * @since 0.1.0-alpha.4
     */
    includeColourFormats?: {
        hex?: boolean;
        hsl?: boolean;
        lch?: boolean;
        rgb?: boolean;
    };

    /** @since 0.1.0-alpha.4 */
    includeTargetLevels?: boolean;

    /** @since 0.1.0-alpha.4 */
    includeOnlyUsedLevels?: boolean;

    /**
     * Used to pass custom targets to the shade swatch table.
     *
     * @since 0.1.0-alpha.4
     */
    yardstick?:
        | Tokens_Colour_ShadeMap.JsonReturn<string, ColourLevels_Extended>
        | {
              base: Tokens_Colour_ShadeMap.JsonReturn<
                  string,
                  ColourLevels_Extended
              >;

              /**
               * Colour name to use to find target contrast from base shades.
               */
              accent?: string;
          };
}

const {
    includeColourFormats,
    includeTargetLevels,
    includeOnlyUsedLevels = !!import.meta.env.DEV,
    tokens,
    yardstick,
}: Props = Astro.props;

/* FUNCTION ===================================== */

export async function makeTargetLevels<T_ColourName extends string>(
    sampleColourName: T_ColourName,
    targetShadeMap?:
        | undefined
        | Tokens_Colour_ShadeMap.JsonReturn<T_ColourName, ColourLevels_Extended>
): Promise<LevelTargets | undefined> {
    // returns
    if (!targetShadeMap) {
        return undefined;
    }

    const matchedPairs = [
        ['100', '900'],
        ['150', '850'],
        ['200', '800'],
        ['250', '750'],
        ['300', '700'],
        ['350', '650'],
        ['400', '600'],
        ['450', '550'],
    ] as const;

    const current = await objectMapAsync(
        targetShadeMap,
        async ([level, value]) => {
            level;

            return {
                min: {
                    aa: {
                        ui: value.contrast.min[sampleColourName]?.ui?.aa?.level,
                        text: value.contrast.min[sampleColourName]?.text?.aa
                            ?.level,
                    },
                    aaa: {
                        ui: value.contrast.min[sampleColourName]?.ui?.aaa
                            ?.level,
                        text: value.contrast.min[sampleColourName]?.text?.aaa
                            ?.level,
                    },
                },
                max: value.contrast.max[sampleColourName]?.level,
            } satisfies LevelTargets[keyof typeof targetShadeMap];
        }
    );

    const getMaxLevel = (
        _lvlA?: undefined | ColourLevels | ColourLevels_Extended,
        _lvlB?: undefined | ColourLevels | ColourLevels_Extended
    ): undefined | ColourLevels | ColourLevels_Extended => {
        // returns
        if (!_lvlA || !_lvlB) {
            return undefined;
        }

        _lvlB = ColourUtilities.getDarkLevel(_lvlB);

        const num_A = Number(_lvlA);
        const num_B = Number(_lvlB);

        // // returns
        // if (num_A < 500 && num_B < 500) {
        //     return Math.min(num_A, num_B).toString() as
        //         | ColourLevels
        //         | ColourLevels_Extended;
        // }

        return Math.max(num_A, num_B).toString() as
            | ColourLevels
            | ColourLevels_Extended;
    };

    for (const [level_a, level_b] of matchedPairs) {
        const corrected_a = {
            min: {
                aa: {
                    ui: getMaxLevel(
                        current[level_a].min.aa.ui,
                        current[level_b].min.aa.ui
                    ),
                    text: getMaxLevel(
                        current[level_a].min.aa.text,
                        current[level_b].min.aa.text
                    ),
                },
                aaa: {
                    ui: getMaxLevel(
                        current[level_a].min.aaa.ui,
                        current[level_b].min.aaa.ui
                    ),
                    text: getMaxLevel(
                        current[level_a].min.aaa.text,
                        current[level_b].min.aaa.text
                    ),
                },
            },
            max: getMaxLevel(current[level_a].max, current[level_b].max),
        } satisfies LevelTargets[keyof typeof targetShadeMap];

        current[level_a] = corrected_a;

        current[level_b] = {
            min: {
                aa: {
                    ui:
                        corrected_a.min.aa.ui &&
                        ColourUtilities.getDarkLevel(corrected_a.min.aa.ui),
                    text:
                        corrected_a.min.aa.text &&
                        ColourUtilities.getDarkLevel(corrected_a.min.aa.text),
                },
                aaa: {
                    ui:
                        corrected_a.min.aaa.ui &&
                        ColourUtilities.getDarkLevel(corrected_a.min.aaa.ui),
                    text:
                        corrected_a.min.aaa.text &&
                        ColourUtilities.getDarkLevel(corrected_a.min.aaa.text),
                },
            },
            max:
                corrected_a.max &&
                ColourUtilities.getDarkLevel(corrected_a.max),
        } satisfies LevelTargets[keyof typeof targetShadeMap];
    }

    return current;
}

/* CONSTANTS ===================================== */

// const defaultToggleToOpen = import.meta.env.DEV ? true : undefined;

const allLevels = Object.keys(tokens.colour.base) as (
    | ColourLevels
    | ColourLevels_Extended
)[];

const levelsInUse = getLevelsInUse(tokens.themes);

const excludeLevels = !includeOnlyUsedLevels
    ? []
    : allLevels.filter((level) => !levelsInUse.has(level));

const yardsticks = yardstick
    ? 'base' in yardstick
        ? yardstick
        : { base: yardstick }
    : undefined;

const levelTargets = {
    base: await makeTargetLevels('base', yardsticks?.base),
    accent:
        yardsticks?.accent &&
        tokens.colour[yardsticks?.accent as keyof typeof tokens.colour]
            ? await makeTargetLevels(yardsticks.accent, yardsticks?.base)
            : undefined,
};
---

<ShadeSwatchTable
    heading={2}
    id='all-colours'
    colour={tokens.colour}
    excludeLevels={excludeLevels}
    includeColourFormats={includeColourFormats}
    includeTargetLevels={includeTargetLevels}
    targets={levelTargets}
    tokens={tokens}
/>

{
    (Object.keys(tokens.colour) as (keyof typeof tokens.colour)[]).map(
        (name) => (
            <Toggle
                class='shades-list-toggle'
                heading={2}
                id={`shades-${name}`}
            >
                <Fragment
                    set:text={`All ${toTitleCase(name)} Shades`}
                    slot='button'
                />
                <ShadeSwatchList
                    bases={tokens.colour.base}
                    colour={tokens.colour[name]}
                    id={`shades-${name}__list`}
                    name={name}
                    shadeHeading={3}
                    tokens={tokens}
                />
            </Toggle>
        )
    )
}

<style lang='scss'>
    @forward '../scss/page-content-colour';
</style>
