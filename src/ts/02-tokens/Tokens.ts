/**
 * @since ___PKG_VERSION___
 * 
 * @packageDocumentation
 */
/*!
 * @maddimathon/design-system-utilities@___CURRENT_VERSION___
 * @license MIT
 */

import { JsonToScss } from '@maddimathon/utility-sass';
import * as z from 'zod';

import { AbstractTokens } from './abstracts/AbstractTokens.js';

import { Tokens_Colour } from './Tokens/Colour.js';
import { Tokens_Spacing } from './Tokens/Spacing.js';
import { Tokens_Typography } from './Tokens/Typography.js';

import { Tokens_CSS_Border } from './Tokens/CSS/CSS_Border.js';
import { Tokens_CSS_Transition } from './Tokens/CSS/CSS_Transition.js';
import { Tokens_Theme } from './Tokens/Theme.js';

/**
 * Generates a complete token object for the design system.
 * 
 * @since ___PKG_VERSION___
 */
export class Tokens extends AbstractTokens<
    typeof Tokens.Schema,
    Tokens.Parsed,
    Tokens.Part,
    Tokens.JSON,
    Tokens.ScssVars
> {

    get schema() {
        return Tokens.Schema;
    }

    public readonly colour: Tokens_Colour;
    public readonly spacing: Tokens_Spacing;
    public readonly theme: Tokens_Theme;
    public readonly typography: Tokens_Typography;

    public readonly CSS: {
        border: Tokens_CSS_Border;
        transition: Tokens_CSS_Transition;

        /**
         * Z-index values for CSS.
         * 
         * Default keys are 'nav', 'settings', 'skipLink'.
         */
        zIndex: z.output<typeof Tokens.Schema.shape.CSS.shape.zIndex>;
    };

    public readonly opts: Tokens.Opts;

    public constructor (
        input?: Tokens.Part,
        opts?: Partial<Tokens.Opts>,
    ) {
        super( input ?? {} );

        this.opts = {
            tokensAsDefault: false,
            ...opts,
        };

        this.colour = new Tokens_Colour( input?.colour ?? {} );
        this.spacing = new Tokens_Spacing( input?.spacing ?? {} );
        this.theme = new Tokens_Theme( input?.theme ?? {} );

        this.typography = new Tokens_Typography(
            this.spacing,
            input?.typography ?? {}
        );

        const zIndex = this.schema.shape.CSS.shape.zIndex.parse( input?.css?.zIndex ?? {} );

        this.CSS = {
            border: new Tokens_CSS_Border( input?.css?.border ?? {} ),
            transition: new Tokens_CSS_Transition( input?.css?.transition ?? {} ),
            zIndex,
        };
    }

    public toJSON(): Tokens.JSON {

        return {
            spacing: this.spacing.toJSON(),
            typography: this.typography.toJSON(),

            colour: this.colour.toJSON(),
            theme: this.theme.toJSON(),

            CSS: {
                border: this.CSS.border.toJSON(),
                transition: this.CSS.transition.toJSON(),
                zIndex: this.CSS.zIndex,
            },
        };
    }

    public override toScssVars(): Tokens.ScssVars {

        return {
            ...this.spacing.toScssVars(),
            ...this.typography.toScssVars(),

            border: this.CSS.border.toScssVars(),
            transition: this.CSS.transition.toScssVars(),
            z_index: this.CSS.zIndex,

            colour: this.colour.toScssVars(),
            theme: this.theme.toScssVars(),
        };
    }

    public override toScss(): string {

        const _vars = this.toScssVars();

        const vars: { [ K in keyof Tokens.ScssVars ]: string; } = {

            spacing_multiplier: JsonToScss.convert( _vars.spacing_multiplier ) || String( this.schema.shape.spacing.shape.multiplier.parse( '' ) ),
            margin: JsonToScss.convert( _vars.margin ) || '()',

            font: JsonToScss.convert( _vars.font ) || '()',

            line_height: JsonToScss.convert( _vars.line_height ) || '()',

            border: JsonToScss.convert( _vars.border ) || '()',
            transition: JsonToScss.convert( _vars.transition ) || '()',
            z_index: JsonToScss.convert( _vars.z_index ) || '()',

            colour: JsonToScss.convert( _vars.colour ) || '()',
            theme: JsonToScss.convert( _vars.theme ) || '()',
        };

        const scss: string[] = [
            '// this file is auto-generated by the design-system-utilities Tokens class',
        ];

        const defaultString = this.opts.tokensAsDefault ? ' !default' : '';

        for ( const t_key in vars ) {
            const _key = t_key as keyof typeof vars;

            scss.push( `$${ _key }: ${ vars[ _key ] }${ defaultString };` );
        }

        return scss.join( '\n\n' );
    }

    public valueOf(): Tokens.Parsed {

        return {
            spacing: this.spacing.valueOf(),
            typography: this.typography.valueOf(),

            colour: this.colour.valueOf(),
            theme: this.theme.valueOf(),

            CSS: {
                border: this.CSS.border.valueOf(),
                transition: this.CSS.transition.valueOf(),
                zIndex: this.CSS.zIndex,
            },
        };
    }
}

/**
 * Utilities for the {@link Tokens} class.
 * 
 * @since ___PKG_VERSION___
 */
export namespace Tokens {

    /**
     * Options for the {@link Tokens} class.
     * 
     * @since ___PKG_VERSION___
     */
    export interface Opts {
        tokensAsDefault: boolean;
    };



    /* SCHEMA
     * ====================================================================== */

    export const Schema = z.object( {

        colour: Tokens_Colour.Schema,
        spacing: Tokens_Spacing.Schema,
        theme: Tokens_Theme.Schema,
        typography: Tokens_Typography.Schema,

        CSS: z.object( {

            border: Tokens_CSS_Border.Schema,
            transition: Tokens_CSS_Transition.Schema,

            zIndex: z.object( {
                nav: z.number().default( 1000 ),
                settings: z.number().default( 9999 ),
                skipLink: z.number().default( 99999 ),
            } ),
        } ),
    } );



    /* TYPES
     * ====================================================================== */

    export type Parsed = {
        colour: Tokens_Colour.Parsed;
        spacing: Tokens_Spacing.Parsed;
        theme: Tokens_Theme.Parsed;
        typography: Tokens_Typography.Parsed;

        CSS: {
            border: Tokens_CSS_Border.Parsed;
            transition: Tokens_CSS_Transition.Parsed;
            zIndex: z.output<typeof Schema>[ 'CSS' ][ 'zIndex' ];
        };
    };

    /**
     * The partialized version of the {@link Tokens.Schema} accepted as input.
     *
     * @since ___PKG_VERSION___
     */
    export interface Part {
        colour?: Tokens_Colour.Part;
        spacing?: Tokens_Spacing.Part;
        theme?: Tokens_Theme.Part;
        typography?: Tokens_Typography.Part;

        css?: {
            border?: Tokens_CSS_Border.Part;
            transition?: Tokens_CSS_Transition.Part;

            zIndex?: Partial<Parsed[ 'CSS' ][ 'zIndex' ]>;
        };
    };

    export type JSON = {
        colour: Tokens_Colour.JSON;
        spacing: Tokens_Spacing.JSON;
        theme: Tokens_Theme.JSON;
        typography: Tokens_Typography.JSON;

        CSS: {
            border: Tokens_CSS_Border.JSON;
            transition: Tokens_CSS_Transition.JSON;
            zIndex: Parsed[ 'CSS' ][ 'zIndex' ];
        };
    };

    /**
     * @interface
     */
    export type ScssVars = Omit<Parsed, "colour" | "CSS" | "spacing" | "theme" | "typography">
        & Tokens_Spacing.ScssVars
        & Tokens_Typography.ScssVars
        & {
            border: Tokens_CSS_Border.ScssVars;
            colour: Tokens_Colour.ScssVars;
            theme: Tokens_Theme.ScssVars;
            transition: Tokens_CSS_Transition.ScssVars;
            z_index: Parsed[ 'CSS' ][ 'zIndex' ];
        };
}