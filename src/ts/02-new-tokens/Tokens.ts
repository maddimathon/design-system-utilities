/**
 * @since ___PKG_VERSION___
 * 
 * @packageDocumentation
 */
/*!
 * @maddimathon/design-system-utilities@___CURRENT_VERSION___
 * @license MIT
 */

import { JsonToScss } from '@maddimathon/utility-sass';
// import * as z from 'zod';

import type { TokenLevels_Extended } from './@utils.js';

import { AbstractTokens } from './abstract/AbstractTokens.js';
import { Tokens_Colour } from './Tokens_Colour.js';
import { Tokens_CSS } from './Tokens_CSS.js';
import { Tokens_Spacing } from './Tokens_Spacing.js';
import { Tokens_Typography } from './Tokens_Typography.js';

/**
 * Generates a complete token object for the design system.
 * 
 * @since ___PKG_VERSION___
 */
export class Tokens<
    T_ColourName extends string,
    T_ExtraColourLevels extends TokenLevels_Extended,
> extends AbstractTokens<Tokens.Data<T_ColourName, T_ExtraColourLevels>> {

    public get data() {
        return {
            colour: this.colour.data,
            spacing: this.spacing.data,
            typography: this.typography.data,
            css: this.css.data,
        };
    }

    public readonly colour: Tokens_Colour<T_ColourName, T_ExtraColourLevels>;
    public readonly spacing: Tokens_Spacing;
    public readonly typography: Tokens_Typography;
    public readonly css: Tokens_CSS;

    /**
     * Used instead of the constructor so that it can be async.
     */
    public static async build<
        T_ColourName extends string,
        T_ExtraColourLevels extends TokenLevels_Extended,
    >(
        clrNames: readonly T_ColourName[],
        extraColourLevels: readonly T_ExtraColourLevels[],
        input: Tokens.InputParam<T_ColourName, T_ExtraColourLevels>,
        config: Partial<Tokens.Config> = {},
    ): Promise<Tokens<T_ColourName, T_ExtraColourLevels>> {

        const tokens = new Tokens( clrNames, extraColourLevels, input, config );

        await tokens.colour.addContrastTests();

        return tokens;
    }

    protected constructor (
        protected readonly clrNames: readonly T_ColourName[],
        protected readonly extraColourLevels: readonly T_ExtraColourLevels[],
        protected readonly input: Tokens.InputParam<T_ColourName, T_ExtraColourLevels>,
        protected readonly config: Partial<Tokens.Config> = {},
    ) {
        super();

        this.colour = new Tokens_Colour(
            this.clrNames,
            this.extraColourLevels,
            this.input.colour ?? {},
        );

        this.spacing = new Tokens_Spacing( this.input.spacing ?? {} );
        this.typography = new Tokens_Typography( this.input.typography ?? {} );
        this.css = new Tokens_CSS( this.input.css ?? {} );
    }

    public toJSON(): Tokens.JsonReturn<T_ColourName, T_ExtraColourLevels> {

        return {
            spacing: this.spacing.toJSON(),
            typography: this.typography.toJSON(),
            colour: this.colour.toJSON(),
            css: this.css.toJSON(),
        };
    }

    public toScssVars() {

        return {
            ...this.spacing.toScssVars(),
            ...this.typography.toScssVars(),
            ...this.css.toScssVars(),

            colour: this.colour.toScssVars(),
        };
    }

    public override toScss(): string {

        const _vars = this.toScssVars();

        const vars: { [ K in keyof typeof _vars ]: string; } = {

            spacing_multiplier: JsonToScss.convert( _vars.spacing_multiplier ) || Tokens_Spacing.default.multiplier.toString(),
            margin: JsonToScss.convert( _vars.margin ) || '()',

            font: JsonToScss.convert( _vars.font ) || '()',

            line_height: JsonToScss.convert( _vars.line_height ) || '()',

            border: JsonToScss.convert( _vars.border ) || '()',
            transition: JsonToScss.convert( _vars.transition ) || '()',
            z_index: JsonToScss.convert( _vars.z_index ) || '()',

            colour: JsonToScss.convert( _vars.colour ) || '()',
        };

        const scss: string[] = [
            '// this file is auto-generated by the design-system-utilities Tokens class',
        ];

        const defaultString = this.config.tokensAsDefault ? ' !default' : '';

        for ( const t_key in vars ) {
            const _key = t_key as keyof typeof vars;

            scss.push( `$${ _key }: ${ vars[ _key ] }${ defaultString };` );
        }

        return scss.join( '\n\n' );
    }
}

/**
 * Utilities for the {@link Tokens} class.
 * 
 * @since ___PKG_VERSION___
 */
export namespace Tokens {

    /**
     * Configuration options for the {@link Tokens} class.
     * 
     * @since ___PKG_VERSION___
     */
    export interface Config {
        tokensAsDefault: boolean;
    };

    export type Data<
        T_ColourName extends string,
        T_ExtraColourLevels extends TokenLevels_Extended,
    > = {
        colour: Tokens_Colour.Data<T_ColourName, T_ExtraColourLevels>;
        spacing: Tokens_Spacing.Data;
        typography: Tokens_Typography.Data;
        css: Tokens_CSS.Data;
    };

    export interface InputParam<
        T_ColourName extends string,
        T_ExtraColourLevels extends TokenLevels_Extended,
    > {
        colour?: undefined | Tokens_Colour.InputParam<T_ColourName, T_ExtraColourLevels>;
        spacing?: undefined | Tokens_Spacing.InputParam;
        typography?: undefined | Tokens_Typography.InputParam;
        css?: undefined | Tokens_CSS.InputParam;
    }

    export type JsonReturn<
        T_ColourName extends string,
        T_ExtraLevels extends TokenLevels_Extended,
    > = {
        colour: Tokens_Colour.JsonReturn<T_ColourName, T_ExtraLevels>;
        spacing: Tokens_Spacing.JsonReturn;
        typography: Tokens_Typography.JsonReturn;
        css: Tokens_CSS.JsonReturn;
    };
}